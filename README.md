数据结构与算法

什么是数据结构？什么事算法？

	从广义讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。

关系

	数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构上。

20个最常用的、最基础的数据结构与算法

	10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、tree树。

	10个算法：递归、排序、二分法查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规则、字符串匹配算法。

复杂度分析方法

什么是复杂度分析？

- 数据结构和算法解决的是“如何让计算机更快、更省控件的解决问题”。
- 因此需要从执行时间和占用空间两个维度来评估数据结构和算法的性能。
- 分别用时间复杂度和空间复杂度两个概念来描述性能问题，二者统称为复杂度。
- 复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。

为什么进行复杂度分析？

- 和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性能强的特点。
- 掌握了复杂度分析，将能够编写出性能更优的代码，有利于降低系统开发和维护成本。

大O复杂度表示法

	算法的执行时间于每行代码的执行次数成正比，用（T(n) = O(f(n))）,其中T(n)表示算法执行总时间，f(n)表示每行代码执行次数总和，而n表示数据的规模大小。

	大O时间复杂度实际上并不是具体的表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度，简称时间复杂度。

	公式中的低阶、常数、系数三部分并不左右增长趋势，所以都可以忽略。

时间复杂度分析

1.只关注执行次数最多的一段代码。

2.加法法则：总复杂度等于量级最大的那段代码的复杂度。

	T1(n) = O(f(n)), T2(n) = O(g(n)) ;T(n) = T1(n)+T2(n) = max(O(f(n)) + O(g(n))) = O(max(f(n),g(n)))

3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积。

	T1(n) = O(f(n)), T2(n) = O(g(n)) ;T(n) = T1(n)*T2(n) = O(f(n)) * O(g(n)) = O(f(n)*g(n))

4.多个规模求加法：比如方法有两个参数控制的两个循环的次数，那么这时就取二者复杂度相加。

几个常见的时间复杂度实例分析

常量阶 O(1)

对数阶 O(logn)

线性阶 O(n)

线性对数阶 O(nlogn) 递归、快速排序法

平方阶 O(n^2)

指数阶 O(2^n)

阶乘 O(n!)

空间复杂度

	表示算法的存储空间于数据规模之间的增长关系，又称渐进控件复杂度。

复杂度的四个概念

1.最坏情况时间复杂度

	代码在最糟糕的情况下执行的时间复杂度。

2.最好情况时间复杂度

	代码在最理想的情况下执行的时间复杂度。

3.平均时间复杂度

	代码在所有情况下执行的次数和加权平均值表示。

4.均摊时间复杂度

	代码执行的所有复杂情况中，绝大部分情况是低级别复杂度，只有极少数情况是高级别复杂度，可以将高级别复杂度均摊到低级别复杂度上，基本均摊结果就等于低级别复杂度。

数组

如何实现随机访问？

	数组是一种线性数据结构。它用连续的内存空间，来存储一组具有相同类型的数据。

特点

1.线性表

	线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只能有前后两个方向。链表、队列、栈都是线性表结构，与之相反，二叉树、堆、图叫非线性表。

2.连续的内存空间和相同的数据类型

	由于这两个特性（连续的内存空间和相同的数据类型），数组最大的特点或者优势就是支持随机访问，但就是由于这两个限制也让数组在删除、插入数据时效率很低，如果想在数组中删除、插入一个数据，为了保证数据的连续性，就需要做大量的数据搬移工作。

原理

	假如分配一个10个元素的数据 int[] a = new int[10],这时计算机在内存分配了一块连续的内存空间1000~1039，其中，内存块的首地址为base_address = 1000,计算机会给每个内存单元分配一个地址。计算机通过地址来访问内存中的数据，当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出元素的存储内存地址。

    寻址公式：a[i]_address = base_address + i * data_type_size

注意表述：数组支持随机访问，根据下标随机访问的时间复杂度是O(1)，不要说成查找元素的时间复杂度是O(1)，而二分法查找，时间复杂度是O(logn).

ArrayList vs Array

ArrayList 最大的优势就是将对数组的操作封装起来，另一个优势就是动态扩容，当存储空间不够的时候，它会将空间自动扩容到1.5倍。

ArrayList无法存储基本数据类型，需要封装为Integer,Long,Autoboxing和Unboxing有一定的性能消耗。

Array定义时需要指定大小，多维数组。

链表

数组和链表数据结构

- 数组需要连续的内存空间来存储。
- 链表不需要连续的内存存储空间。

链表的结构

- 单链表、双向链表和循环链表。

数组和链表插入、删除和查找时间复杂度对比

	数组进行插入和删除时，为了保证数据的连续性，需要做大量的数据迁移，所以时间复杂度是O(n)，而在单链表中插入和删除数据，不需要保持内存的连续性而迁移结点，应为单链表的存储空间本身就是不连续的，所以在链表中插入和删除一个数据时很快的，时间复杂度是O(1)。

	有利有弊，链表想要随机访问第K个元素，相比之下就没有数组高效，因为链表中的数据并非连续存储，无法向数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应元素的内存存储地址，而是根据指针一个结点一个结点的遍历，指导找到对应的元素，时间复杂度是O(n)。

循环链表

	循环链表是一种特殊的单项链表，区别在于尾结点，循环链表的尾结点指向首结点，而单链表指向空。

关于数组和链表的时间复杂度对比

	注意：需要区分链表类型（单链表、双向链表和循环列表）

1）在链表中进行删除操作

- 删除结点中”值等于某个给定值“的结点。
  无论是单链表或双向链表，为了查找到的值等于给定的值，都需要重头进行查找，一个结点一个结点的对比，直到找到给定的值，尽管单纯删除的时间复杂度是O(1)，但是需要进行元素查找，对应时间复杂度是O(n)，根据加法法则，时间复杂度是O(n).
- 删除给定指针指向的结点。
  对于删除某个结点，需要知道前驱结点，单项链表由于不知道给定节点的前驱节点，需要重头遍历。双向链表已经知道前驱结点是谁，所以不需要像单链表那样从头遍历，双向链表在O(1)时间内搞定，单链表需要在O(n)时间的时间复杂度。

指针

	将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或则反过来，指针中存储了这个变量的内存地址，指向了这个变量，通过这个指针就能找到这个变量。











